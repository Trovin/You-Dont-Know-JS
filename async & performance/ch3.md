# Вы не знаете JS: Асинхронность и Производительность
# Глава 3: Промисы

В Главе 2 мы выявили две основные категории недостатков при использовании колбэков для выражения асинхронности программы и управления параллелизмом: отсутствие последовательности и проблема доверия (инверсия контроля). Теперь, когда мы более глубоко понимаем проблемы, пришло время обратить внимание на паттерны, которые должны эти проблемы решить.

Проблема, которую мы хотим решить в первую очередь — это инверсия контроля, доверие, которое так тяжело удержать и так легко потерять.

Напомним, что мы оборачиваем *продолжение* нашей программы в колбэк, передавая его исполнение другой (возможно, сторонней) программе и скрестив пальцы надеемся, что все будет работать правильно.

Под продолжением подразумевается это: «вот что произойдет *позже*, после того, как завершится текущий шаг».

Но что, если бы существовала парадигма, позволяющая избавиться от этой инверсии контроля? Что, если вместо того, чтобы передать *продолжение* нашей программы другой стороне, мы могли бы ожидать, что программа даст нам возможность узнать, когда закончится выполнение ее текущего шага? Что, если бы наша программа решала, что делать дальше?

Эта парадигма называется **Промисы**

Промисы стремительно ворвались в мир JS, поскольку к тому времени разработчики отчаянно боролись с «callback hell» в своем коде. Фактически, большинство новых асинхронных API, создаются на промисах. Так что, наверное, неплохо бы изучить их, не так ли?

**Примечание:**. Слово «немедленно» будет использоваться часто в этой главе, как правило, для ссылки на какое-либо действие промисов.

## Что такое промис?

Когда разработчики решают научиться новой технологии, обычно первым делом они сразу приступают к изучению синтаксиса этой технологии. Для нас совершенно естественно начинать прыгать, когда мы только учимся ходить.

Но оказывается, что некоторые абстракции тяжело понять только по API. Промисы — один из тех инструментов, где это особенно очевидно. Это становится серьезной проблемой для тех, кто не изучает механизмы работы промисов, а сразу переходит к использованию API.

Поэтому, прежде чем я покажу код промисов, я хочу полностью объяснить концепцию, лежащую в их основе. Я надеюсь, что это поможет вам лучше применять их на практике.

Давайте посмотрим на две разные аналогии, объясняющие суть промисов.

### Будущее значение

Представьте себе такую ситуацию: я подхожу к стойке в кафе и заказываю чизбургер. Передав деньги, я создал своего рода запрос, в ответ на который я получу чизбургер. Я начал транзакцию.

Но не всегда в ответ на такой запрос чизбургер возвращается сразу. Кассир вручает мне нечто вместо моего чизбургера: квитанцию с номером заказа на нем. Этот номер заказа — это долговое обязательство («Я должен вам»), которое гарантирует, что в конечном итоге я должен получить чизбургер.

Пока я жду, я могу делать другие вещи, например, написать сообщение другу: «Пообедаешь со мной? Я буду чизбургер».

Я уже рассуждаю о моем *будущем чизбургере*, хотя у меня его еще нет. Номер заказа мой мозг использует, как аналогию, временный «заменитель» чизбургера. «Заменитель» делает значение независимым от времени. Это **будущая ценность**.

В конце концов, я слышу: «Заказ 113!» и я радостно возвращаюсь к стойке с квитанцией в руке. Я вручаю свою квитанцию кассиру, и получаю чизбургер взамен.

Другими словами, как только моя **будущая ценность** была готова, я обменял квитанцию о ценности на саму ценность.

Но есть еще один вариант событий. Кассир называет мой номер заказа, но когда я иду, чтобы получить чизбургер, кассир с сожалением сообщает мне: «Извините, но мы, кажется, продали все чизбургеры». Отбросив мое разочарование на мгновение, мы можем увидеть важную характеристику будущих значений: они могут означать либо успех, либо неудачу.

Каждый раз, когда я заказываю чизбургер, я знаю, что в конечном итоге я получу или чизбургер, или печальную новость о том, что они кончились, и мне придется выяснять, что еще есть на обед.

**Примечание:** В коде все не так просто, потому что метафорически номер заказа может быть никогда не вызван, и в этом случае мы остаемся на неопределенное время в неопределенном состоянии. Мы вернемся к этому позже.

#### Значения сейчас и потом

Конечно это все звучит довольно абстрактно. Давайте конкретизируем.

Однако, прежде чем мы сможем представить, как промисы работают, возьмем решение, которое мы уже изучили - колбэки! - посмотрим, как они справятся с *будущими значениями*.

Когда вы пишете код, оперируя значением, например, выполняя математические действия с числами, понимаете ли вы это или нет, вы подразумеваете что-то очень фундаментальное в отношении этого значения, то есть это конкретное значение *уже сейчас*:

```javascript
var x, y = 2;

console.log( x + y ); // NaN  <-- потому что `x` еще не установлено значение
```

Операция `x + y` предполагает, что значения и `x`, и `y` уже установлены. Иными словами, мы предполагаем, что значения `x` и `y` уже *разрешены (получены)*.

Было бы бессмысленно ожидать, что оператор `+` сам каким-то образом будет способен обнаруживать и ждать до тех пор, пока не будут разрешены (иначе говоря, готовы) как `х`, так и `y`, и только тогда выполнять операцию. Это может привести к хаосу в программе.

Как бы мы тогда рассуждали о взаимодействии между двумя инструкциями, если одна из инструкций еще в ожидании? Если вторая инструкция полагается на завершение первой, то возможны два результата: либо первая инструкция завершается прямо *сейчас*, и все идет хорошо, либо инструкция еще не завершилась, и, следовательно, вторая инструкция не выполнится.

Отлично, если это вам показалось похожим на то, что мы изучали в первой главе.

Вернемся к нашей математической операции `x + y`. Представьте себе, что существует способ сказать: «Сложи `x` и `y`, но если какого-то из значений еще нет, то подожди, пока оба значения будут установлены. И сложи их, как только сможешь».

Возможно, ваш мозг предложит вам решение на колбэках. Итак...

```javascript
function add(getX, getY, cb) {
	var x, y;
	getX( function(xVal){
		x = xVal;
		// оба значения готовы?
		if (y != undefined) {
			cb( x + y );	// сложить значения
		}
	} );
	getY( function(yVal){
		y = yVal;
		// оба значения готовы?
		if (x != undefined) {
			cb( x + y );	// сложить значения
		}
	} );
}

// `fetchX()` и`fetchY()` могут быть синхронными или асинхронными
// functions
add( fetchX, fetchY, function(sum){
	console.log( sum ); // это было просто, да?
} );
```

Хотя уродство этого кода неоспоримо, нужно кое-что подчеркнуть.

В этом фрагменте мы рассматриваем `x` и `y`, как будущие значения, и мы описываем операцию `add(..)`, которую не волнует, доступны ли `x` или `y` сразу или нет. Иными словами функция согласует понятия *сейчас* и *потом*, поэтому мы можем полагаться на предсказуемый результат операции `add(..)`.

Используя функцию `add(..)`, согласованную по времени — она ведет себя одинаково и `сейчас` и `позже` — мы получаем асинхронный код, который гораздо проще анализировать.

Иными словами: последовательно обрабатывая как `сейчас`, так и `позже`, мы выполняем их оба `позже`. То есть асинхронно.

Конечно, написанный на коленке код, основанный на колбэках, оставляет желать лучшего. Это всего лишь первый шаг к пониманию преимущества анализа *будущих значений*, не беспокоясь о том доступны ли эти значения или еще нет.

#### Значения промисов

Мы обязательно подробно расскажем о промисах позже в этой главе - так что не волнуйтесь, если некоторые определения вам будут непонятны [речь о реджекте и резолве. — _прим. перев_.]. Давайте просто кратко взглянем на то, как мы можем реализовать пример `x + y` через Промисы:

```javascript
function add(xPromise,yPromise) {
	// `Promise.all([ .. ])` принимает массив промисов,
	// и возвращает новый промис
	// который ждет, пока остальные промисы из массива зарезолвятся
	return Promise.all( [xPromise, yPromise] )

	// когда и этот промис зарезолвится,
	// возьмем полученные значения `X` and `Y` и сложим вместе.
	.then( function(values){
		// `values` это массив вернувшийся
		// в результате резолва предыдущих промисов
		return values[0] + values[1];
	} );
}

// `fetchX()` and `fetchY()` возвращают промисы для значений X и Y соответственно, которые могут быть готовы
// *сейчас* или *потом*.
add( fetchX(), fetchY() )

// мы получаем промис, возвращающий сумму
// двух чисел.
// по цепочке мы вызываем `then(..)` ждущий резолва
// вернувшегося промиса.
.then( function(sum){
	console.log( sum ); //
} );
```

В этом примере есть два уровня промисов.

`fetchX()` и `fetchY()` вызываются напрямую, а возвращаемые значения (в виде промисов) передаются в `add(..)`. Значения, которые возвращают промисы, могут быть готовы *сейчас* или *позже*, но каждый промис выстраивает свою работу независимо от этого. Мы рассуждаем о значениях `X` и `Y` независимо от времени. Это будущие значения.

Второй уровень - это промис, создаваемый `add(..)` (с помощью `Promise.all ([..])`), возврата которого мы ждем, вызывая `then(..)`. Когда операция `add(..)` завершается, наши будущие значения будут готовы, и мы сможем их использовать. Мы скрываем внутри `add(..)` логику ожидания значений `X` и `Y`.

**Примечание:** Внутри `add(..)` вызов `Promise.all([..])` создает промис (который ждет резолва по `promiseX` и `promiseY`). Вызов `.then (..)` создает другой промис, которое сразу же резолвит значение `return values[0] + values[1]` (с результатом сложения). Таким образом, вызов `then(...)`, который мы связываем с завершением вызова `add(..)` — в конце примера — фактически работает над возвратом второго промиса, а не первого, созданного `Promise.all([ .. ])`. Кроме того, хотя мы не связываем результат второго `then(..)`, он тоже создаёт промис, результат которого мы можем использовать, если понадобится. Этот механизм связывания промисов будет рассмотрен более подробно позже в этой главе.

Как и в случае с заказом чизбургера, возможно, что результат промиса - это `реджект` (т.е ошибка, отказ), а не `резолв`. В отличие от выполненного `(зарезолвленного)` промиса, значение которого запрограммировано, значение реджекта, может быть либо задано непосредственно логикой программы, либо оно может неявно вытекать во время выполнения программы.

Таким образом `then(...)` может фактически принимать две функции, первую для резолва (как показано выше), а вторую для реджекта.

```javascript
add( fetchX(), fetchY() )
.then(
	// обработка резолова
	function(sum) {
		console.log( sum );
	},
	// обработка реджекта
	function(err) {
		console.error( err ); // bummer!
	}
);
```

Если что-то пошло не так при получении значений `X` или `Y` или при сложении, промис, который возвращает `add(..)`, будет зареджектен, а второй обработчик ошибок, переданный в `then(..)`, получит значение реджекта.

Поскольку промис инкапсулируют зависящее от времени состояние (ожидание резолва или реджекта) от внешней среды, то сам промис не зависит от времени, и, таким образом, промисы ведут себя предсказуемо.

Более того, как только промис выполняется, его значение становится *неизменяемым*. Его можно использовать столько раз сколько потребуется.

**Примечание:** Поскольку промис является неизменным после его выполнения, то его значение можно передавать куда угодно, и быть уверенным, что его нельзя модифицировать случайно или намеренно. Это особенно верно в отношении нескольких частей программы, использующих значение промиса. Невозможно, чтобы одна часть повлияла на способность другой части использовать это значение. Неизменяемость (иммутабельность) может звучать по-академически сложно, но на самом деле это один из самых фундаментальных и важных аспектов работы промисов.

Промисы — это удобная концепция для повторной работы с *будущими значениями*.

### Событие завершения

Как мы только что видели, отдельный промис ведет себя, как `будущее значение`. Но есть еще один способ выразить работу промисов: как механизм управления потоком по времени (`это-затем-то`) для двух или более шагов в асинхронной задаче.

Представим себе вызов функции `foo(..)` для выполнения некоторой задачи. Мы не знаем ни о каких деталях ее работы, да и в общем они нам и не нужны. Функция  может выполнить задачу или сразу или это может занять некоторое время.

Нам просто нужно знать, когда `foo(..)` закончится, чтобы мы могли перейти к следующей задаче. Другими словами, мы хотели бы получить уведомление о завершении `foo(..)`, чтобы *продолжить*.

В JavaScript, если вам нужно подписаться на уведомление, вы, вероятно, подумаете об этом с точки зрения событий. Иными словами: нам нужно подписаться на событие `завершения` (`или продолжения`), переданное от `foo(..)`.

**Примечание:** Использование «события завершения» или «события продолжения», зависит от наших дальнейших действий. Что нам нужно: то, что происходит во время выполнения `foo(..)`, или что происходит после завершения `foo(..)`? Оба этих действия важны. Уведомление о событии не только сообщает нам, что `foo(..)` *завершено*, но также говорит нам, что все в порядке, чтобы *продолжить* следующий шаг. Действительно, колбэк, который вы передаете для вызова уведомления о событии, сам по себе является тем, что мы ранее называли *продолжением*.

В версии с колбэками «уведомление» будет колбэком, вызванным задачей (`foo(..)`). Но с промисами мы ожидаем, что мы сможем прослушать событие из `foo(..)`, и, когда вас уведомят, то сделать соответствующие действия.

Рассмотрим следующий псевдокод:

```javascript
foo(x) {
	// начинаем делать то, что займет некоторое время
}

foo( 42 )

on (foo "completion") {
	// теперь мы можем приступить к следующему шагу!
}

on (foo "error") {
	// упс, что-то пошло не так в `foo(..)`
}
```

Мы вызываем `foo(..)`, а затем устанавливаем два слушателя событий, один для «завершения» и один для «ошибки» — двух возможных конечных результата вызова `foo(..)`. По сути, `foo(..)` не знает, что вызывающий код подписался на эти события, что дает очень хорошее `разделение сущностей`.

К сожалению, для такого кода потребуется некоторая «магия», которой не существует в JS. Вот более естественный способ описать это в JS:

```javascript
function foo(x) {
	// начинаем делать то, что займёт некоторое время

	// создаем `listener`, уведомляющий о событии

	return listener;
}

var evt = foo( 42 );

evt.on( "completion", function(){
	// теперь мы можем приступить к следующему шагу!
} );

evt.on( "failure", function(err){
	// упс, что-то пошло не так в `foo(..)`
} );
```
`foo(..)` создает возможность подписки на события для возврата, а вызывающий `foo` код получает и регистрирует два обработчика событий.

Инверсия из нормального обратного кода должна быть очевидной, это сделано намеренно. Вместо того, чтобы передавать обратные вызовы в `foo(..)`, он возвращает функцию события, которую мы вызываем `evt`, которая получает обратные вызовы.

Должно быть очевидным отличие от обычного (на колбэках) кода. Вместо того, чтобы передавать колбэки в `foo(..)`, мы вызываем функцию события, которая принимает колбэки.

Но вспомните главу 2 — сами колбэки подвержены `инверсии контроля`. Поэтому инвертирование шаблона колбэка на самом деле является `инверсией инверсии`  — восстановлением контроля обратно.

Одним из важных преимуществ является то, что нескольким отдельным частям кода может быть предоставлена возможность прослушивания событий, и они могут независимо получать уведомления о том, когда `foo(..)` завершает выполнение:

```javascript
var evt = foo( 42 );

// пусть `bar(..)` регистрирует завершение `foo(..)`
bar( evt );

// так же, пусть `baz(..)` регистрирует завершение `foo(..)`
baz( evt );
```
*Инверсия инверсии* позволяет лучше *разделить ответственность*, т.к `bar(..) `и `baz(..)` не нужно участвовать в вызове `foo(..)`. Точно так же `foo(..)` не нужно знать, что `bar(..)` и `baz(..)` существуют или ждут уведомления завершении `foo()`.

По сути, объект `evt` является нейтральным способом общения между функциями с разделённой ответственностью.

#### «Событие завершения» на промисах

Как вы уже догадались, возможность прослушивания событий `evt` является аналогом промисов.

В варианте, основанном на промисах, предыдущий фрагмент кода создавал бы `foo()` и возвращал экземпляр промиса, и этот промис затем передавался бы в `bar(..)` и `baz(..)`.

**Примечание:** «События», которые мы слушаем — это не события в прямом смысле (хотя они, безусловно, ведут себя именно так), и их обычно не называют «завершением» или «ошибкой». Вместо этого мы используем `then(..)` для регистрации события «then». Или более точно — `then(..)` регистрирует событие `fulfillment (выполнение)` и/или `rejection (отклонение)`, хотя явно мы не видим их использования в коде.


Рассмотрим пример:

```javascript
function foo(x) {
	// начинаем делать что то, что займет время

	// создаем и возвращаем промис
	return new Promise( function(resolve,reject){
		// по сути, вызов `resolve(..)` или `reject(..)`,
		// это варианты колбэков для выполнения
		// промиса.
	} );
}

var p = foo( 42 );

bar( p );

baz( p );
```

**Примечание:** Паттерн `new Promise (function (..) {..})` называется «раскрывающим конструктором (Revealing Constructor)». Передаваемая функция выполняется немедленно и ей передаются два параметра, которые мы назвали `resolve` и `reject`. Это функции выполнения промиса. `resolve(..)` отвечает за `fulfillment`-стадию и `reject(..)` за `rejection`-стадию.

Вероятно, вы можете догадаться,`bar(..)` и `baz(..)` внутри:

```javascript
function bar(fooPromise) {
	// слушаем, когда `foo(..)` закончится
	fooPromise.then(
		function(){
			// `foo(..)` закончилась, so
			// выполняем `bar(..)`
		},
		function(){
			// упс, что-то пошло не так в `foo(..)`
		}
	);
}

// то же самое для `baz(..)`
```

Другой вариант:

```javascript
function bar() {
	// `foo(..)` определенно завершилось
	// выполняем `bar(..)`
}

function oopsBar() {
	// упс, что-то пошло не так в foo(..)`,
	// `bar(..)` не запустится
}

// тоже самое для `baz()` и `oopsBaz()`

var p = foo( 42 );

p.then( bar, oopsBar );

p.then( baz, oopsBaz );
```
**Примечание:** Если раньше вы уже использовали промисы, то вы можете предположить, что последние две строки этого кода можно записать как `p.then( .. ).then( .. )`, используя связывание. У такого варианта было бы совершенно другое поведение, поэтому будьте осторожны! Разница может быть не совсем понятна прямо сейчас, но на самом деле это другой асинхронный шаблон:`split / forking`. Не волнуйтесь! Мы еще вернемся к этому вопросу позже в этой главе.

Вместо того, чтобы передавать промис в `bar(..)` и `baz(..)`, мы используем промис для контроля выполнения `bar(..)` и `baz(..)` , если они вообще выполнятся. Основное различие заключается в обработке ошибок.

В первом случае `bar(..)` вызывается независимо от того, как завершится `foo(..)` (успешно или нет), и обрабатывает свою собственную логику на случай, если получено уведомление, что `foo(..)` «упало». То же самое верно для `baz(..)`.

Во втором случае `bar(..)` вызывается только в том случае, если `foo(..)` завершается успешно, иначе вызывается `oopsBar(..)`. То же верно и для `baz(..)`.

Ни один из подходов не является правильным. Будут случаи, когда один предпочтительнее другого.

В любом случае промис `p`, возвращаемый от `foo(..)`, используется для контроля того, что произойдет дальше.

Более того, тот факт, что оба фрагмента заканчиваются вызовом `then(..)` иллюстрирует ранее сделанный вывод, которая заключается в том, что промисы после выполнения навсегда сохраняют одно и то же состояние (`fullfillment` или `rejection`).

Всякий раз, когда `p` выполнится, следующий шаг всегда будет таким же, как `сейчас`, так и `позже`.

## «Тогдашняя» утиная типизация

Как точно узнать, является ли какое-то значение промисом или нет. Или более точно — будет ли значение вести себя, как промис?

Учитывая, что промисы создается через  `new Promise(..)`, вы можете подумать, что `p instanceof Promise` будет истиной. Но, к сожалению, существует ряд причин, по которым это не так.

Вы можете получить значение промиса из другого окна браузера (iframe и т.д.), которое будет иметь свой собственный промис, отличный от того, который находится в текущем окне/фрейме, и проверка не сможет идентифицировать экземпляр промиса.

Более того, библиотеки или фреймворки могут предоставлять свои собственные промисы, реализация которых отличается от реализации промисов в `ES6` . Также вы вполне можете использовать промисы с библиотеками в старых браузерах, которые не поддерживают промисы.

Итак, было решено, что способ распознать промис (или что-то, что ведет себя как промис) — это определить некую сущность, называемую `«thenable»` («тогдашний»). Это любой объект или функция, у которого(-ой) есть метод `then(...)`. Предполагается, что любое такое значение является совместимым с промисом.

Общий прием для «проверки типов», который делает предположения о «типе» значения в зависимости от его свойств, называется «утиная типизация» — «Если это выглядит как утка, плавает как утка и крякает как утка, то, вероятно, это утка». Таким образом, «утиная типизация» для `thenable` будет примерно такой:

```javascript
if (
	p !== null &&
	(
		typeof p === "object" ||
		typeof p === "function"
	) &&
	typeof p.then === "function"
) {
	// предположительно, это thenable!
}
else {
	// не thenable
}
```

Если вы попытаетесь выполнить промис с любым значением объекта/функции, на которых можно применить `then(..`), но при это вы не предполагали, что это промис / `thenable`, то вам не повезло. Он будет автоматически распознаваться как `thenable` и обрабатываться специальными правилами (см. далее в главе).

Это даже хорошо, если вы не осознали, что на объекте/функции есть `then(..)`. Например:

```javascript
var o = { then: function(){} };

// свяжем `v` через `[[Prototype]]` с `o`
var v = Object.create( o );

v.someStuff = "cool";
v.otherStuff = "not so cool";

v.hasOwnProperty( "then" );		// false
```

`v` не похож на промис или `thenable`. Это простой объект с некоторыми свойствами.


Но `v` при этом также является связанным через [[Prototype]] с другим объектом `o`, который имеет `then(..)`. Это значит, что проверка «утиной типизацией» покажет, что `v` это `thenable`. Нехорошо.

``` javascript
Object.prototype.then = function(){};
Array.prototype.then = function(){};

var v1 = { hello: "world" };
var v2 = [ "Hello", "World" ];
```

Предполагается, что и `v1` и `v2` будут `thenable`. Вы не можете контролировать или прогнозировать, если какой-либо другой код случайно или намеренно добавит `then(..)` в Object.prototype, Array.prototype или любой другой нативный прототип. И если указано, что это функция, которая не вызывает ни один из ее параметров в качестве колбэков, то любой промис, выполненный с таким значением, будет просто зависать навсегда!

Звучит неправдоподобно или маловероятно? Может быть.

Но имейте в виду, что перед ES6 существовало несколько известных не-промис-библиотек, у которых уже был методы, называемые `then(..)`. Некоторые из этих библиотек решили переименовать эти методы, чтобы избежать коллизий (это отстой!). Другие просто убрали эти методы из за «несовместимости с промисами».

**Предупреждение**: Мне не нравится, что мы используем «утиную типизацию» для определения промисв. Были и другие варианты, такие как «брендинг» или даже «анти-брендинг»; то, что мы получили, похоже на худший компромисс. Но не стоит отчаиваться. В некоторых случаях «утиная типизация» может быть полезна, далее мы увидим это. Нужно иметь в виду и остерегаться того, что «утиная типизация» может не правильно идентифицировать некую сущность, как промис, хотя эта сущность промисом не является.

## Промисы и проблемы доверия

Мы увидели две аналогии (будущие значения и события завершения), которые объясняют разные аспекты того, что промисы могут сделать для нашего асинхронного кода. Однако, мы еще не рассмотрели самую важную вещь, которую дают промисы: доверие.

Начнем с разбора проблем доверия, которые порождаются колбэками. Когда вы передаете колбэк утилите `foo(..)`, она может:

* Вызвать колбэк слишком рано
* Вызвать колбэк слишком поздно (или вообще не вызвать)
* Вызвать колбэк гораздо больше раз (или гораздо меньше), чем нужно
* В нее невозможно передать произвольные параметры
* Ошибки и исключения могут не обработаться

Особенности промисов решают эти проблемы

### Ранний вызов

В первую очередь проблема связана с тем, может ли код приводить к Залго-эффектам (см. Главу 2). Такое может происходить, когда задача может завершаться как синхронно, так и асинхронно, что может привести к «состоянию гонки».

Промисы по определению не подвержены этой проблеме, потому что даже незамедлительно выполненный промис (например, `new Promise(function (resolve) {resolve (42);})`) не может *наблюдаться* синхронно.

То есть, когда вы вызываете `then(..)` в промисе, даже если этот промис уже выполнен, колбэк, который вы передаете в `then(..)`, всегда будет вызываться асинхронно (более подробно об этом, в части «Задания», в главе 1).

Вам больше не нужен `setTimeout(..,0)`-хак. Промисы убивают Залго автоматически.

### Поздний вызов

Как и в предыдущем пункте, `then(..)` автоматически планируются к выполнению (по аналогии с колбэками), когда `resolve(..)` или `reject(..)` вызываются. `then(...)` будет предсказуемо запущен в следующий асинхронный момент (см. «Задания» в главе 1).

Когда промис выполнен, все `then(..) ` на нем будут вызваны по порядку, сразу при следующей асинхронной возможности (опять же, см. «Задания» в главе 1), и ничто, происходящее внутри отдельного `then'a ` не может повлиять на другие.

 Например:

 ```javascript
 p.then( function(){
 	p.then( function(){
 		console.log( "C" );
 	} );
 	console.log( "A" );
 } );
 p.then( function(){
 	console.log( "B" );
 } );
 // A B C
 ```
 Здесь «C» не может прервать и выполниться раньше «B», в силу специфики работы промисов.

#### Планирование промисов и их причуды

 Однако важно отметить, что существует множество нюансов планирования, относительно порядка выполнения отдельных промисов.

 Если оба промиса `p1` и `p2` уже разрешены, то должно быть верно, что `p1.then(..); p2.then(..)` в конечном итоге вызовет колбэк(и) для `p1` до `p2`. Но есть редкие случаи, когда это не так, например:

 ```javascript
 var p3 = new Promise( function(resolve, reject){
 	resolve( "B" );
 } );

 var p1 = new Promise( function(resolve, reject){
 	resolve( p3 );
 } );

 var p2 = new Promise( function(resolve, reject){
 	resolve( "A" );
 } );

 p1.then( function(v){
 	console.log( v );
 } );

 p2.then( function(v){
 	console.log( v );
 } );

 // A B  <-- но не  B A  как вы могли предположить
 ```

Мы рассмотрим это подробнее позже, но, как вы можете видеть, `p1` выполняется не моментально, а с другим промисом `p3`, который сам выполняется со значением «B». Специфичность этого случая в том, что `p3` разворачивается внутри `p1` асинхронно. Поэтому колбэк `p1` находится после колбэка `p2` в асинхронной очереди (см. Главу 1).

Чтобы избежать таких проблем, вы никогда не должны полагаться на порядок колбэков, вызываемых через промисы. На самом деле, хорошая практика заключается в том, чтобы не писать код таким образом, что важен порядок выполнения колбэков. Избегайте этого, если сможете.

### Колбэк, который не был вызван

Это очень распространенная проблема. Она решается несколькими путями с помощью промисов.

Во-первых, ничто (даже ошибка JS) не может помешать промису уведомить вас о его выполнении. Если вы опишите оба колбэка (`fullfillment` и `rejection`) для промиса, и промис выполнится, то один из колбэков всегда будет вызван.

Конечно, если ваши колбэки имеют ошибки, вы можете не увидеть ожидаемый результат, но колбэк при этом будут вызван. Позже мы расскажем о том, как получить уведомление об ошибке в колбэке.

Но что, если промис никогда не будет зарезолвлен? Это условие, использует абстракцию более высокого уровня, называемую «гонка»:

```javascript
// a utility for timing out a Promise
function timeoutPromise(delay) {
	return new Promise( function(resolve,reject){
		setTimeout( function(){
			reject( "Timeout!" );
		}, delay );
	} );
}

// устанавливаем таймаут для `foo()`
Promise.race( [
	foo(),					// attempt `foo()`
	timeoutPromise( 3000 )	// give it 3 seconds
] )
.then(
	function(){
		// `foo(..)` выполнилось вовремя!
	},
	function(err){
		// либо `foo()` зареджектилось, или
		// не выполнилось вовремя, нужно проверить
		// `err` чтобы узнать причину
	}
);
```

Есть больше деталей, которые следует учитывать при использовании таймаутов вместе с промисами, но мы вернемся к нему позже.

Важно отметить, что мы можем обеспечить уведомление относительно завершения `foo()`, чтобы он не «подвешивал» программу на неопределенный срок.

### Вызов слишком мало или слишком много раз

«Слишком мало» также может означать «ноль раз», что приравнивается к «не вызовется никогда», что мы уже рассмотрели выше.

Случай «слишком много» легко объяснить. Промисы работают так, что они могут выполниться лишь один раз. Если по какой-то причине промис попытается вызвать `resolve(..)` или `reject(..)` несколько раз или пытается вызвать их оба, то будет приниматься только первый выполненный результат, а остальные будут игнорироваться.

Поскольку промис может быть выполнен только один раз, все описанные `then(...)` также вызовутся один раз.

Конечно, если вы явно опишите вызов `then()` более одного раза (например, `p.then (f); p.then (f);`), он будет вызываться столько раз, сколько был описан. Гарантия того, что функция вызывается только один раз, не мешает вам выстрелить в ногу.

### Невозможность передать произвольные параметры

Промисы могут иметь максимум одно значение выполнения (`fullfillment` или `rejection`).

Если вы явно или не явно не указываете значение, оно будет равно `undefined` (это весьма характерно для JS). При этом оно всегда будет передаваться всем зарегистрированным (и соответствующим состояниям: `fullfillment` или `rejection`) колбэкам, как *сейчас*, так и в будущем.

Нужно оговорить одну особенность: если вы вызываете `resolve(..)` или `rejection(..)` с несколькими параметрами, все последующие параметры за исключением первого игнорируются. Это может показаться нарушением правила, которое мы только что описали, но на самом деле это является неправильным использованием механизма промисов. Другие неправильные способы использования API промисов (например `resolve(..)` несколько раз) имеют такую же защиту.

Если вы хотите передать несколько значений, вы должны обернуть их в `массив` или `объект`.

Что касается среды, функции в JS всегда сохраняют замыкание области, в которой они определены, поэтому они, конечно, будут иметь доступ к любому окружающему состоянию, которое вы предоставляете. Поэтому мы можем с уверенностью положиться на это.

### Игнорирование ошибок/исключений

В определенном смысле это повторение предыдущих выводов. Если вы отклоните (`reject`) промис по *причине* (например, сообщение об ошибке), то значение передастся в колбэк отклонения.

Но в этом утверждении кроется нечто большее. Если в любой момент создания промиса или при наблюдении за его выполнением возникает ошибка исключения JS, такая как `TypeError` или `ReferenceError`, это исключение будет поймано, и это заставит промис отклониться (перейти в состояние `rejected`).

Например:

```javascript
var p = new Promise( function(resolve, reject){
	foo.bar();	// `foo` is not defined, это ошибка!
	resolve( 42 );	// этот код никогда не выполнится :(
} );

p.then(
	function fulfilled(){
		// никогда не выполнится :(
	},
	function rejected(err){
		// `err` будут `TypeError` объектом исключения
		// полученным от `foo.bar()` строки в коде.
	}
);
```

Исключение JS, которое происходит мы получаем из `foo.bar()`, становится отклонением промиса, которое мы можем обработать.

Это важная деталь, потому что она эффективно решает проблему Залго, которая заключается в том, что ошибки могут создавать синхронную реакцию, тогда как нормальное выполнение программы будет асинхронным. Промисы делают даже исключения JS асинхронными, тем самым значительно уменьшая шансы на условие гонки.

Но что произойдет, если промис успешно выполнится, но во время наблюдения за ним возникнет ошибка исключения JS (в некотором `then(..)`)? Эти исключения не потеряются, но то ,как они будут обработаны, удивит вас:

```javascript
var p = new Promise( function(resolve, reject){
	resolve( 42 );
} );

p.then(
	function fulfilled(msg){
		foo.bar();
		console.log( msg );	// никогда не выполнится :(
	},
	function rejected(err){
		// никогда не выполнится :(
	}
);
```
Похоже, что исключение из `foo.bar()` не было зафиксировано. Но не бойтесь, это не так. Но что то внутри механизма промисов пошло не так. А именно — то, что мы не можем обработать это исключение. Вызов `p.then(..)` возвращает другой промис, и именно этот промис будет отклонен с помощью исключения `TypeError`.

Почему он не мог просто вызвать обработчик ошибок, который мы там определили? Это было бы логичным поведением. Но это нарушит основополагающий принцип, согласно которому промис **иммутабелен** после выполнения. `p` уже был выполнен со значением `42`. Поэтому его нельзя позже заменить на отклонение только потому, что есть ошибка в выполнении `p`.

Помимо принципиального нарушения, такое поведение может привести к хаосу. Если, скажем, было несколько `then(..)` зарегистрированных для `p`, некоторые из них вызвались бы, а другие - нет, и было бы очень непонятно почему.

### Надежность промисов

Это последняя деталь для изучения промисов.

Вы, несомненно, заметили, что использование промисов не отменяет использования колбэков. Они просто меняют место вызова колбэка. Вместо того, чтобы передавать колбэк `foo(..)`, мы получаем *нечто* (якобы промис) из `foo(..)`, и мы передаем колбэк этому *нечто*.

Но почему это более надежная конструкция, чем просто колбэки по старинке? Как мы можем быть уверены, что *нечто*, которое мы получаем, это промис? Разве это вообще не просто карточный домик, где мы можем доверять только потому, что уже однажды доверились?

Одна из самых важных, но часто забываемых деталей промисов — заключается в том, что промисы решают проблему карточного домика. В нативную реализацию промисов входит `Promise.resolve(..)`.

Если вы передадите не-промис, не-thenable значение в `Promise.resolve(..)`, вы получите промис, который зарезолвится с этим значением. Другими словами, эти два промиса `p1` и `p2` будут вести себя одинаково:

```javascript
var p1 = new Promise( function(resolve, reject){
	resolve( 42 );
} );

var p2 = Promise.resolve( 42 );
```

Но, если вы передадите настоящий промис в `Promise.resolve(..)`, то вам вернется тот же самый промис:

```javascript
var p1 = Promise.resolve( 42 );

var p2 = Promise.resolve( p1 );

p1 === p2; // true
```

Помните наш предыдущий разговор о `thenable`?

Рассмотрим:

```javascript
var p = {
	then: function(cb) {
		cb( 42 );
	}
};

// это работает, но лишь благодаря счастливой случайности
p
.then(
	function fulfilled(val){
		console.log( val ); // 42
	},
	function rejected(err){
		// код здесь никогда не выполнится
	}
);
```

`p` это `thenable` , но это не настоящий промис и что, если вам вернулось что-то такое:

```javascript
var p = {
	then: function(cb, errcb) {
		cb( 42 );
		errcb( "зловещий смех" );
	}
};

p
.then(
	function fulfilled(val){
		console.log( val ); // 42
	},
	function rejected(err){
		// упс, это не должно запуститься
		console.log( err ); // зловещий смех
	}
);
```

`p` это `thenable`, но оно ведет себя не как промис. Является ли оно вредоносным? Или оно игнорирует механизм работы промисов? Честно говоря, это не имеет никакого значения. В любом случае, проблема доверия имеет место быть.

Тем не менее, мы можем передать любой из вариантов `p` в `Promise.resolve(..)`, и мы получим безопасный и ожидаемый результат:

```javascript
Promise.resolve( p )
.then(
	function fulfilled(val){
		console.log( val ); // 42
	},
	function rejected(err){
		// никогда не выполнится
	}
);
```

`Promise.resolve(..)` будет принимать любые `thenable` данные и преобразует их в `не-thenable`. Из `Promise.resolve(..)` мы получаем промис, *которому вы можете доверять*. Если то, что вы передали, уже является промисом, вы просто получите его обратно.

Итак, предположим, что мы вызываем утилиту `foo(..)`, и мы не уверены, что полученное значение будет промисом. `Promise.resolve(..)` предоставит нам надежную обертку в виде промиса:

```javascript
// не делайте так:
foo( 42 )
.then( function(v){
	console.log( v );
} );

// делайте так:
Promise.resolve( foo( 42 ) )
.then( function(v){
	console.log( v );
} );
```

**Примечание**: другой положительный эффект от оборачивания функции в `Promise.resolve(..)` — это легкий способ вызвать функцию асинхронно. `foo(..)` может или немедленно вернуть значение или вернуть промис. `Promise.resolve(..)` гарантирует, что возвращаемое значение всегда будет промисом.

### Доверие получено

Надеюсь, теперь в вашем сознании полностью «зарезолвилось» понимание надежности промисов. И что еще более важно у вас появилось понимание, почему эта надежность настолько важна для создания универсального, поддерживаемого программного обеспечения.

Можете ли вы писать асинхронный код в JS «на авось»? Конечно можете. Разработчики на JS, писали асинхронный код не имея ничего, кроме колбэков в течение почти двух десятилетий.

Но когда вы начинаете задумываться, насколько такие решения предсказуемы и надежны, то вы начинаете понимать, что на одни только колбэки нельзя положиться.

Промисы - это решение, которое дополняет колбэки надежной семантикой, делая их поведение более разумным и надежным. Нейтрализуя инверсию контроля колбэков, мы получаем надежную систему, которая была разработана специально для внесения здравого смысла в асинхронные программы.

## Связывание

Важно понимать, что промисы - это не просто механизм для одноэтапной операции `это-затем-то`. Оказывается, мы можем объединить несколько промисов вместе, чтобы создать последовательность асинхронных шагов.

Ключ к использованию связывания, заключается в двух особенностях:

* Каждый раз, когда вы вызываете `then(..)` , он создает и возвращает новый промис, связанный с предыдущим
* Независимо от того, какое значение вы вернете из fullfillment-колбэка `then(...)` (первый параметр), это значение автоматически попадет в fullfillment-колбэк `связанного` промиса.

Давайте сначала проиллюстрируем, что это значит, и тогда мы узнаем, как это помогает нам создавать асинхронные последовательности:

```javascript
var p = Promise.resolve( 21 );

var p2 = p.then( function(v){
	console.log( v );	// 21

	// fulfillment `p2` со значением `42`
	return v * 2;
} );

// обрываем цепочку `p2`
p2.then( function(v){
	console.log( v );	// 42
} );
```

Возврат `v * 2` - это `fullfillment` промиса `p2`, который был создан первым вызовом `then(..)`. `then(..)`, вызванный от промиса `p2`, получит fullfillment-значение уже от выполнения операции `return v * 2`. Разумеется `p2.then(..)`, создаст и вернет другой промис, который мы можем сохранить в переменную `p3`.

К счастью, у нас есть возможность не создавать каждый раз промежуточную переменную `p2` (или `p3`), вместо этого мы можем применить `связывание`:

```javascript
var p = Promise.resolve( 21 );

p
.then( function(v){
	console.log( v );	// 21

	// выполняем свзанный промис со значением `42`
	return v * 2;
} )
// и связываем их дальше
.then( function(v){
	console.log( v );	// 42
} );
```
Итак, теперь первый `then(..)` является первым шагом в асинхронной последовательности, а второй `then(..)` вторым. Вы можете увеличивать цепочку настолько, насколько вам необходимо. Просто продолжайте связывать предыдущий `then(..)` с каждым автоматически созданным промисом.

Но здесь чего-то не хватает. Что делать, если мы хотим, чтобы шаг 2 ожидал, что шаг 1 сделает что-то асинхронное? Мы используем операцию `return`, которая сразу же выполняет связанный промис.

Ключом к тому, чтобы сделать последовательность промисов действительно асинхронной на каждом шаге, - это вспомнить, как работает `Promise.resolve(..)`, когда то, что вы передаете ему, является промисом или `thenable`. `Promise.resolve(..)` напрямую возвращает полученный промис, или  разворачивает значение полученного `thenable`.

Подобное разворачивание происходит, если вы возвращаете `thenable` или промис из обработчика выполнения(fullfillment) или отклонения(rejection):

```javascript
var p = Promise.resolve( 21 );

p.then( function(v){
	console.log( v );	// 21

	// создаем промис и возвращаем его
	return new Promise( function(resolve, reject){
		// выполняем промис со значением `42`
		resolve( v * 2 );
	} );
} )
.then( function(v){
	console.log( v );	// 42
} );
```
Несмотря на то, что мы поместили `42` в промис, который мы вернули, разворачивание все еще происходит и заканчивается выполнением связанного промиса. Так что второй `then(..)` все еще получает 42. Если мы добавим асинхронности этому промису, все по-прежнему хорошо работает:

```javascript
var p = Promise.resolve( 21 );

p.then( function(v){
	console.log( v );	// 21

	// создаем и возвращаем промис
	return new Promise( function(resolve, reject){
		// добавляем асинхронности!
		setTimeout( function(){
			// выполняем со значением  `42`
			resolve( v * 2 );
		}, 100 );
	} );
} )
.then( function(v){
	// запустится после задержки на предыдущем шаге в 100 миллисекунд
	console.log( v );	// 42
} );
```

Невероятная мощь! Теперь мы можем создавать любую асинхронную последовательность, которую захотим, и каждый шаг может задержать следующий шаг (или нет!), при необходимости.

Конечно, значение, передаваемое от шага к шагу в этих примерах, является необязательным. Если вы не возвращаете явную величину значения, то оно будет равно `undefined`, при этом промисы также будут связаны вместе. Таким образом, каждое завершение промиса является лишь сигналом для перехода к следующему шагу.

Расширим иллюстрацию связывания, вынеся создание промиса с задержкой в отдельную утилиту:

```javascript
function delay(time) {
	return new Promise( function(resolve, reject){
		setTimeout( resolve, time );
	} );
}

delay( 100 ) // шаг 1
.then( function STEP2(){
	console.log( "шаг 2 (после 100 миллисекунд)" );
	return delay( 200 );
} )
.then( function STEP3(){
	console.log( "шаг 3 (после еще 200 миллисекунд)" );
} )
.then( function STEP4(){
	console.log( "шаг 4 (следующая задача)" );
	return delay( 50 );
} )
.then( function STEP5(){
	console.log( "шаг 5 (после еще 50 миллисекунд)" );
} )
...
```

Вызов `delay(200)` создает промис, который успешно выполнится через 200 миллисекунд и который мы вернем из первого `then(..)`, что заставит второй `then(..)` ждать эти 200 миллисекунд для своего выполнения и так далее.

**Примечание:** Как ясно из описания, технически у нас есть два промиса: промис с задержкой в 200 мс и второй промис связанный через `then(..)`. Но вам может быть проще мысленно объединить эти два промиса вместе, потому что механизм промисов автоматически объединяет их состояния. В этом отношении вы можете думать о задержке `delay(200)` как о создании промиса, который заменяет ранее связанный промис.

Честно говоря, последовательности задержек с отсутствием передачи сообщений - это плохой пример использования промисов. Давайте посмотрим на сценарий, который немного более практичен.

Вместо таймеров рассмотрим создание ajax-запросов:

```javascript

// ajax работает с промисом
function request(url) {
	return new Promise( function(resolve,reject){
		// `ajax(..)` колбэк, должен  быть
		// функцией резолва промиса
		ajax( url, resolve );
	} );
}
```

Сперва мы определим утилиту `request()`, которая создаёт промис по завершении вызова `ajax()`:

```javascript
request( "http://some.url.1/" )
.then( function(response1){
	return request( "http://some.url.2/?v=" + response1 );
})
.then( function(response2){
	console.log( response2 );
});
```

**Примечание:** Разработчики обычно сталкиваются с ситуациями, в которых они хотят выполнять управление потоками асинхронных сообщений промисов, с помощью утилит, которые сами по себе не совместимы с промисами (например, `ajax(..)`, которая ожидает колбэка). Хотя собственный механизм ES6 промисов автоматически не решает эту проблему, ее решают практически все библиотеки, построенные на промисах. Обычно они называют этот процесс «лифтингом» или «промисификацией». Мы вернемся к этой технике позже.

Используя `request(..)`, мы создаем первый шаг в нашей цепочке неявно, обрабатывая первый URL и связывая его с промисом, который вернулся от первого `then(..)`

Когда `response1` вернется, мы используем это значение для обработки второго URL и создания второго вызова `request()`. Этот второй вызов вернет промис, таким образом третий шаг нашей асинхронной цепи будет дожидаться выполнения этого ajax-запроса. Наконец, как только `response2` вернется, выведем его в консоль.

Цепочка промисов, которую мы создаем, - это не только управление потоком в виде многошаговой последовательности, но и канал, передающий сообщения между шагами.

Что, если что-то пошло не так на одном из шагов? Обработка ошибок/исключений сводится к тому. чтобы отловить ошибку в любой точке цепи, и как бы "сбросить" цепочку к нормальной работе.

```javascript
// шаг 1:
request( "http://some.url.1/" )

// шаг 2:
.then( function(response1){
	foo.bar(); // undefined, ошибка!

	// эта часть никогда не выполнится
	return request( "http://some.url.2/?v=" + response1 );
} )

// шаг 3:
.then(
	function fulfilled(response2){
		// не выполнится
	},
	// обработчик, отлавливающий ошибку
	function rejected(err){
		console.log( err );	// `TypeError`
		return 42;
	}
)

// шаг 4:
.then( function(msg){
	console.log( msg );		// 42
} );
```

Когда ошибка возникает на шаге 2, обработчик ошибки на шаге 3 ловит его. Возвращаемое значение (42 в этом фрагменте), если оно есть, от этого обработчика  резолвит следующий промис (шаг 4), так что цепочка продолжает работать.

**Примечание:** Как мы обсуждали ранее, при возвращении промиса от fullfillment-обработчика происходит "разворачивание", которое может задержать следующий шаг. Это также верно для возврата промисов от rejection-обработчиков. Таким образом, если `return 42` на шаге 3 возвращал бы промис, это задерживало бы шаг 4. Исключение внутри fullfillment- или rejection-обработчика в `then(..)` приводит в реджекту следующего связанного промиса.

Если вы вызовете `then(..)` и передадите ему только fullfillment-обработчик, то обработчик отклонения будет заменен на дефолтный:

```javascript
var p = new Promise( function(resolve,reject){
	reject( "Oops" );
} );

var p2 = p.then(
	function fulfilled(){

	}
	// предполагаемый обработчик отклонения
	// либо пропущенный,
	// либо получивший на вход что-то отличное от функции
	// function(err) {
	//     throw err;
	// }
);
```

Как вы можете видеть, предполагаемый обработчик реджекта возвращает ошибку, вынуждая `p2` (связанный промис) зареджектиться с этой же ошибкой. По сути, ошибка продолжит распространяться по цепочке промисов до тех пор, пока не встретится явно определенный rejection-обработчик.

**Примечание:** Обработку ошибок в промисах мы рассмотрим подробно чуть позже. Сейчас нужно сосредоточиться на других деталях.

Для fullfillment-обработчика справедливо тоже самое: если мы не передали его в `then()`, то он будет заменен:

```javascript
var p = Promise.resolve( 42 );

p.then(
	// предполагаемый fullfillment-обработчик
	// function(v) {
	//     return v;
	// }
	null,
	function rejected(err){
		// никогда не выполнится
	}
);
```

Как вы можете видеть, дефолтный fullfillment-обработчик просто передает любое значение, которое он получает, на следующий шаг.

**Примечание:** Конструкция `then(null, function(err){ .. })`, которая служит только для обработки ошибок (если они есть), может быть заменена специальным шорткатом: `catch( function(err){ .. })`. Мы рассмотрим его позднее.

Давайте кратко рассмотрим внутренние механизмы промисов, которые позволяют управлять связыванием:

* Вызов `then(...)` автоматически создает новый промис
* В зависимости от того, что вернул fullfillment- или rejection-обработчик, следующий связанный промис выполнится с соответствующим значением.
* Если fullfillment- или rejection-обработчик вернул промис, то независимо от того, как выполнится этот промис (резолв или реджект), результат выполнения передастся в следующий связанный промис.

Нужно понимать, что связывание это не основная идея использования промисов. Думайте об этом, как о полезном дополнении. Как мы уже обсуждали подробно несколько раз, промисы нормализуют асинхронность и инкапсулируют зависящее от времени значение состояния, и именно это позволяет связывать их.

Конечно, связывание выглядит более совершенным инструментом, чем тот бардак колбэков из Главы 2. В следующей главе мы рассмотрим еще более продвинутый инструмент для построения последовательностей: генераторы.

### Терминология: Resolve, Fullfill, Reject

Существует некоторая путаница в этих терминах. Поэтому необходимо внести ясность, прежде чем более детально продолжить изучение промисов. Рассмотрим функцию-конструктор промиса:

```javascript
var p = new Promise( function(X,Y){
	// X() для fulfillment
	// Y() для rejection
} );
```
Как вы можете видеть, предусмотрены два колбэка (обозначенные X и Y). Первый *обычно* используется для обозначения промиса, как выполненного. Второй *всегда* обозначает промис, как отклоненный. Но что такое «обычно», и что насчет того, как эти параметры названы?

В конечном итоге, движку все равно как будут названы эти параметры, это *нетехническая* проблема. Те слова, которые вы подбираете для функций влияют не только на ваше восприятие программы, но и на восприятие других разработчиков. Неправильное восприятие асинхронного кода почти наверняка будет хуже, чем `callback hell`.

Значение второго параметра легко объяснить. Его название `reject()` очень точно передает суть того, что он делает. Настоятельно рекомендую вам использовать `reject()`.

С первым параметром все не так однозначно. `resolve()` значит "решить" или "разрешить" или "выполнить". По отношению к промису, это может трактоваться, как установка финального состояния/значения. Мы уже говорили "промис зарезолвился", что означает выполнения промиса с fullfillment- или rejection-значением.

Но, если этот параметр используется для конкретного выполнения промиса, то почему бы не назвать его `fullfill` вместо `resolve`? Для ответа на этот вопрос рассмотрим два метода из API промисов:

```javascript
var fulfilledPr = Promise.resolve( 42 );

var rejectedPr = Promise.reject( "Oops" );
```

`Promise.resolve(...)` создает промис, который резолвится со значением, которое в него передали. В нашем случае 42 это не промис и не `thenable`, поэтому `fulfilledPr` создается для значения 42.

`Promise.reject("Oops")` создает промис `rejectedPr`, который реджектится со значением 'Oops'.

Теперь покажем, почему слово 'resolve' является более точным и однозначным:

```javascript
var rejectedTh = {
	then: function(resolved, rejected) {
		rejected( "Oops" );
	}
};

var rejectedPr = Promise.resolve( rejectedTh );
```

Как мы обсуждали ранее в этой главе, `Promise.resolve(...)` вернет или промис или 'тогдашний'. Если обнаруживается, что `thenable` зареджектился, то нам вернется промис в reject-состоянии.

Поэтому можно считать, что `Promise.resolve(...)` это хорошее и точное название для API метода, поскольку он приводит выполнению промиса в fullfillment или rejection-состоянии.

```javascript
var rejectedPr = new Promise( function(resolve, reject){
	// резолв этого промиса вернет промис в состоянии reject
	resolve( Promise.reject( "Oops" ) );
} );

rejectedPr.then(
	function fulfilled(){
		// никогда не выполнится
	},
	function rejected(err){
		console.log( err );	// "Oops"
	}
);
```

Теперь должно стать понятно, почему имя `resolve` выбрано для первого параметра промиса.

**Внимание:** `reject(..)` не может "разворачивать" свои аргументы, как `resolve(..)`. Если вы передадите промис или `thenable` в `reject()`, то их значение не будет вычислено (развернуто), и последующий обработчик ошибки получит промис/`thenable`, а не его значение.

Теперь обратим внимание на колбэки, которые предоставляет `then(..)`. Как их следует назвать? Я предположу, что `fulfilled(..)` и `rejected(..)`:

```javascript
function fulfilled(msg) {
	console.log( msg );
}

function rejected(err) {
	console.error( err );
}

p.then(
	fulfilled,
	rejected
);
```

В случае первого параметра, передаваемого в `then(..)`, все однозначно - это действительно всегда fullfillment-случай и тут нет дуализма понятий, связанного со смыслом "resolve". Следует заметить, что спецификация ES6 использует `onFulfilled(..)` и `onRejected(..)` для обозначения этих двух колбэков, поэтому мое предположение выше верное.

## Обработка ошибок

Мы уже видели несколько примеров отклонения промиса - это может, как и намеренный вызов `reject(..)`, так и внезапно возникшее JS-исключение. Промисы позволяют нам более корректно обрабатывать ошибки при асинхронном программировании. Самое время обсудить детали обработки ошибок, которые мы опускали до этого.

Наиболее используемой формой обработки ошибок для большинства разработчиков, является конструкция `try...catch`. Но, к сожалению, она работает только с синхронным кодом.

```javascript
function foo() {
	setTimeout( function(){
		baz.bar();
	}, 100 );
}

try {
	foo();
	// позже выдаст глобальную ошибку от `baz.bar()`
}
catch (err) {
	// никогда не выполнится
}
```

Существуют некоторые стандарты для обработки ошибок с использованием шаблонов. В первую очередь это "error-first колбэк":

```javascript
function foo(cb) {
	setTimeout( function(){
		try {
			var x = baz.bar();
			cb( null, x ); // успех!
		}
		catch (err) {
			cb( err );
		}
	}, 100 );
}

foo( function(err,val){
	if (err) {
		console.error( err ); // упс :(
	}
	else {
		console.log( val );
	}
} );
```

**Примечание:** в этом примере `try...catch` сработает только в том случае, если `baz.bar()` вызовется немедленно, синхронно. Если внутри `baz.bar()` выполняется какая-то асинхронная операция, то асинхронные ошибки не будут обработаны.

Колбэк, который мы передаем в `foo(..)`, ожидает получить сигнал об ошибке с помощью первого параметра `err`. Если присутствует, допускается ошибка. Если нет, предполагается успех.

Технически такая обработка ошибок *асинхронна*, но она не подходит. Множество уровней с "error-first колбэком", вместе с этими вездесущими `if`, неизбежно приведет вас к "callback hell" (см. Главу 2).

Итак, мы возвращаемся к обработке ошибок в промисах с помощью rejection-обработчика, передаваемого в `then(..)`. В промисах вместо "error-first" метода используется метод "разделения колбэков" — есть один колбэк для fullfillment-варианта и один для rejection.

```javascript
var p = Promise.reject( "Oops" );

p.then(
	function fulfilled(){
		// никогда не выполнится
	},
	function rejected(err){
		console.log( err ); // "Oops"
	}
);
```

На первый взгляд этот метод покажется понятным. Однако, нюансы обработки ошибок в промисах часто гораздо более сложные.

Рассмотрим:

```javascript
var p = Promise.resolve( 42 );

p.then(
	function fulfilled(msg){
		// к числам нельзя применить строковые операции
		// поэтому это приведет к ошибке
		console.log( msg.toLowerCase() );
	},
	function rejected(err){
		// никогда не выполнится
	}
);
```

Если `msg.toLowerCase()` упадет с ошибкой (а так и будет, поверьте), то почему это пройдет мимо обработчика ошибок? Как уже объяснялось ранее, причина в том, что *этот* обработчик описан для промиса `p`, который в свою очередь уже выполнен(fullfill) со значением `42`. Промис `p` иммутабелен, поэтому единственный промис, который может получить сигнал об ошибке, это тот, который вернулся от `p.then(..)`. Но в нашем случае мы его не можем обработать.

Вырисовывается четкая картина того, почему обработка ошибок в промисах является подверженной ошибкам (какая ирония).

**Внимание:** Если вы неправильно(невалидно) используете API промисов, то возникает ошибка нарушающая правильную работу промиса. И ошибка эта будет JS-исключением, а не **отклоненным промисом**. Вот некоторые примеры неправильного использования API: `new Promise(null), Promise.all(), Promise.race(42)`. Вы не можете получить отклоненный промис, если неправильно используете API.

### Яма отчаяния

Jeff Atwood сказал пару лет назад: языки программирования работают таким образом, что разработчики по умолчанию попадают в "яму отчаяния" (http://blog.codinghorror.com/falling-into-the-pit-of-success/): место, где ошибки жестоко караются, и вам нужно приложить много усилий, чтобы их не совершать.  Он предлагал вместо этого создать "яму успеха", где по умолчанию ваши действия успешны, и, следовательно, нужно постараться, чтобы совершить ошибку.

Обработка ошибок в промисах это, несомненно, "яма отчаяния". По умолчанию предполагается, что все ошибки игнорируются состоянием промиса, и, если вы забыли проследить за состоянием, то ошибка будет "тихонько отсиживаться в углу" и, в конце концов, умрёт от отчаяния.

Дабы избежать игнорирования ошибок, некоторые разработчики стали использовать такую "лучшую практику": в конце цепочки промисов должен быть "catch()":

```javascript
var p = Promise.resolve( 42 );

p.then(
	function fulfilled(msg){
		// к числам нельзя применить строковые операции
		// поэтому это приведет к ошибке
		console.log( msg.toLowerCase() );
	}
)
.catch( handleErrors );
```
Поскольку мы не передали обработчик ошибок в `then()`, то ошибка просто передаётся дальше в цепочке. Таким образом, ошибки попавшие в `p` и ошибки, возникшие *после* выполнения `p` (msg.toLowerCase()), передадутся в самый конец цепочки в `handleErrors`.

Проблема решена? Не так быстро.

Что случится, если ошибка произойдет внутри `handleErrors()`? Кто обработает её? Тут упущен из виду ещё один промис: тот, который вернулся из `catch(..)`. Его ошибки никак не отлавливаются, для него не описан обработчик ошибок.

Вы не можете добавить к нему еще один `catch(..)` - он тоже упадет с ошибкой. Последний шаг в цепочке промисов всегда должен иметь возможность (пусть самую примитивную) для обработки ошибки застрявшей в "забытом" промисе.

Звучит, как неразрешимая головоломка?

### Неперехваченная обработка

Решить эту проблему нелегко. Существуют некоторые решения, которые считаются "лучше", чем `catch()` в конце.

Некоторые библиотеки промисов добавляют метод, предоставляющий собой обработчик "глобальных непойманных ошибок". Решение заключается в том, чтобы помечать ошибку, как "непойманную", если она не обработалась в течение определенного времени или таймаута (скажем, 3-х секунд).

На практике такой способ хорошо себя зарекомендовал, поскольку для большинства шаблонов использования промисов не требуется задержки между отклонением (rejection) и наблюдением за тем, как это отклонение обработалось. Но и этот способ имеет свои недостатки: есть некоторые случаи, когда вы хотите, чтобы промис был в rejection-стадии в течение неопределенного периода времени, и в такой ситуации не нужно клеймить ошибки "непойманными".

Еще один способ заключается в методе `done(..)`, который помечает цепочку промисов, как "завершенную, выполненную". `done()` не создает и не возвращает новый промис, поэтому колбэки, которые передаются в `done(..)`, не могут явно сообщить об ошибке.

Но что же происходит вместо этого? Все довольно прозаично: все исключения, появляющиеся в `done(..)` становятся глобальными неперехваченными ошибками (нативная инструкция throw, она появится в консоли)

```javascript
var p = Promise.resolve( 42 );

p.then(
	function fulfilled(msg){
		// к числам нельзя применить строковые операции
		// поэтому это приведет к ошибке
		console.log( msg.toLowerCase() );
	}
)
.done( null, handleErrors );

// если  в `handleErrors(..)` появится исключение, то оно
// вызовет глобальную ошибку
```

Этот способ может быть более привлекательным, чем бесконечная цепочка или произвольные таймауты. Но самая большая проблема заключается в том, что он не является частью стандарта ES6. Поэтому независимо от того, насколько он хорош, в лучшем случае это костыль.

Кажется, что мы застряли? Не совсем.

Браузеры имеют уникальную способность, которой нет у нашего кода: они могут отслеживать "сборку мусора", и указывать какой объект "выбросил" исключение. Таким образом, браузеры могут отслеживать промисы, и всякий раз, когда в "мусоре" есть `rejection`, то браузер наверняка определяет его, как «неперехваченную ошибку» и сообщает об этом в консоль разработчика.

Однако, если промис не попадает в "мусор" -- такую ситуацию легко допустить, учитывая многообразие паттернов программирования -- то проверка браузером "мусора" не даст никакого результата.

Есть ли другие альтернативы? Да.

### Яма успеха

Это пока лишь *теоретический* этап развития промисов. Я считаю, что это будет намного лучше того, что у нас есть. И я думаю, что это изменение будет возможно даже в пост-ES6 эру, потому что, вряд ли оно нарушит спецификацию промисов. Кроме того, если быть осторожным, то такую фичу можно сполифилить. Давайте взглянем:

* Промисы могут по умолчанию сообщать (в консоль разработчика) о любых реджектах в следующем "задании" (Глава 1) или тике цикла событий, если в тот момент не был зарегистрирован обработчик ошибок промиса.

* Для случаев в которых требуется сохранять промис в rejection-состоянии в течение неопределенного времени, можно использовать метод `defer()`, который препятствует автоматическому созданию глобальных ошибок в промисе (ложные срабатывания на "неперехваченных" ошибках).

Если промис зареджектится, то по дефолту об этом будет сообщено в консоль, реджект не сможет "сидеть втихаря". От этой функции можно отказаться: явно (создав обработчик ошибок) или неявно (с помощью `defer()`). В любом случае *вы* осуществляете контроль за ложными срабатываниями.

```javascript
var p = Promise.reject( "Oops" ).defer();

// `foo(..)` использует промисы
foo( 42 )
.then(
	function fulfilled(){
		return p;
	},
	function rejected(err){
		// обработка ошибок в `foo(..)`
	}
);
...
```

Создавая `p`, мы предполагаем, что нам понадобится использовать или наблюдать за реджектом, поэтому мы используем `defer()`. Следовательно, не будет сигналов о глобальных ошибках. `defer()` просто вернет этот же промис для дальнейшего связывания.

Промис, вернувшийся от `foo()`, сразу же получит обработчик ошибок, поэтому глобальная сигнализация ему не нужна.

Однако промис, вернувшийся от `then(..)` не имеет `defer(..)` и обработчика ошибок. Если он зареджектится, то в консоль будет выведено сообщение о "неперехваченной ошибке".

**Это - концепция ямы успеха**. По умолчанию все ошибки обрабатываются или идут в консоль - это то, чего ожидали бы разработчики. Вы либо должны создать обработчик, либо намеренно отказаться от обработки, и указать, что вы намерены отложить (defer) обработку ошибок "на потом"; в этом случае на вас возлагается дополнительная ответственность.

Единственная опасность - это использование `defer()`, но без дальнейшего использования/наблюдения за его rejection-состоянием.

Если вы намеренно использовали `defer()`, чтобы упасть в "яму отчаяния" -- по умолчанию мы в "яме успеха" -- то, никто не сможет уберечь вас от ваших же собственных ошибок.

Я думаю, что все еще есть надежда на продвинутую обработку ошибок (пост-ES6). Я надеюсь, что высшие силы, пересмотрят ситуацию и рассмотрят эту идею. Тем временем вы можете реализовать ее самостоятельно (это настоящий вызов вам!) или использовать более совершенную библиотеку для промисов, которая сделает это за вас!

**Примечание:** продвинутая модель обработки ошибок реализована в моей библиотеке для промисов, более подробно о ней можно прочитать в Приложении А этой книги.

## Паттерны использования промисов

Мы уже касались паттернов использования, когда рассматривали управление потоком через `then(..)`. Но существует гораздо больше паттернов, с помощью которых можно построить абстракции поверх промисов. Эти паттерны служат для упрощения описания механизмов управления потоком — это делает наш код удобным для поддержки даже в самых сложных частях наших программ.

Два таких паттерна есть в реализации промисов в ES6, мы будем использовать их как строительные блоки для других паттернов.

### Promise.all([..])

В асинхронной последовательности (цепочке промисов) только одна задача может обрабатываться в данный момент времени — шаг 2 идет строго за шагом 1, а шаг 3 идет строго за шагом 2. Но как насчет выполнения двух или более шагов одновременно (или «параллельно»)?

В классической терминологии программирования есть понятие «ворота» - это механизм, который ждет выполнения двух или более параллельных задач, прежде чем продолжить выполнение программы. Неважно, в каком порядке они заканчиваются, главное дождаться их завершения, чтобы "ворота открылись" и позволили контролировать поток.

В API промисов, такой паттерн называется `all([..])`.

Скажем, вы хотите сделать два ajax-запроса, в одно и тоже время, подождать пока они завершатся (независимо от порядка их выполнения), и сделать третий запрос:

```javascript
// `request(..)` это утилита, использующая промисы,

var p1 = request( "http://some.url.1/" );
var p2 = request( "http://some.url.2/" );

Promise.all( [p1,p2] )
.then( function(msgs){
	// и`p1` и `p2` успешно выполняются
	// и передают свои сообщения дальше
	return request(
		"http://some.url.3/?v=" + msgs.join(",")
	);
} )
.then( function(msg){
	console.log( msg );
} );

```
`Promise.all([..])` принимает один аргумент - `массив`, в основном состоящий из промисов. Промис, вернувшийся после вызова `Promise.all([..])`, получит массив сообщений (`msgs`), в том же порядке, в котором были указаны промисы `p1 и p2` (независимо от того, у какого промиса fullfillment был раньше).

**Примечание:** Технически, `массив`, передаваемый в `Promise.all([..])` может включать в себя промисы, `thenable` и даже конкретные значения. Каждый элемент массива проходит через `Promise.resolve(..)`, поэтому конкретное значение будет преобразовано в промис. Если массив пустой, то основной промис сразу выполнится(станет fullfilled).

Fullfiled-состояние у основного промиса (который возвращается от `Promise.all([..])`) наступает только в том случае, если все промисы, входящие в массив, перейдут в fullfilled-состояние. Если хотя бы один из промисов зареджектится, основной промис немедленно зареджектится тоже.

Не забывайте создавать обработчики ошибок в промисах, даже в тех, которые возвращаются из `Promise.all([..])`.

### Promise.race([ .. ])

Иногда вам нужно обработать результат только "первого прибежавшим к финишу" промиса, отбрасывая выполнения других промисов.

В классическом программировании эта модель называется "защелкой", в промисах она называется "гонкой" [от англ. "race"].

**Внимание:** Слово "гонка" весьма точно определяет суть паттерна, однако мы уже использовали похожий термин: "условие гонки" из Главы 1, которое приводит к ошибкам в программе. Не путайте понятия "условие гонки" и `Promise.race([ .. ])`.

`Promise.race([..])` также принимает `массив`, включающий в себя промисы, `thenable` и даже конкретные значения. Однако, не имеет никакого практического смысла устраивать "гонку" с конкретным значением, очевидно, что оно выиграет. Это, как устраивать гонку, где один из участников стартует на финише.

`Promise.race([ .. ])` станет fullfilled, если любой из промисов станет fullfilled. И если хотя бы один из промисов зареджектится, основной промис немедленно зареджектится тоже.

**Внимание:** "гонка" требует минимум одного "бегуна", если вы передадите пустой `массив`, то вместо моментального резолва, `Promise.race([ .. ])` вообще никогда не зарезолвится. Это выстрел в ногу! По-хорошему, в ES6 должно быть указано, что промис или выполняется/отклоняется или создается синтаксическая ошибка. Но исторически, из-за предшествующих промисам библиотек, эта фича не была реализована. Поэтому никогда не передавайте пустой `массив `.

Давайте рассмотрим предыдущий пример, но уже в контексте гонки между `p1 и p2`:

```javascript
// `request(..)` это утилита, использующая промисы,

var p1 = request( "http://some.url.1/" );
var p2 = request( "http://some.url.2/" );

Promise.race( [p1,p2] )
.then( function(msg){
	// или p1 или p2 выиграет в гонке
	return request(
		"http://some.url.3/?v=" + msg
	);
} )
.then( function(msg){
	console.log( msg );
} );
```

Так как выигрывает гонку только один промис, то следовательно результатом выполнения будет одно сообщение, не `массив`, в отличие от `Promise.all([ .. ])`.

#### Таймаут гонки

Мы уже использовали этот пример ранее, иллюстрируя, как `Promise.race([ .. ])` может использоваться для "таймаута промиса":

```javascript
// `foo()` использует промисы

// `timeoutPromise(..)`, возвращает промис
// который реджектится, через определенное время

// устанавливаем таймаут для`foo()`
Promise.race( [
	foo(),
	timeoutPromise( 3000 )
] )
.then(
	function(){
		// `foo(..)` выполнился вовремя!
	},
	function(err){
		// или foo() зареджектится
		// или не выполнится вовремя
		// изучите err, чтобы узнать причину
	}
);

```

Паттерн таймаута хорошо работает в разных ситуациях. Но нужно иметь ввиду некоторые нюансы, справедливые и для `Promise.race([ .. ])` и для `Promise.all([ .. ])`.

#### "Наконец"

Ключевой вопрос: "Что случится с промисом, который выбыл из гонки?" Нам не особо интересно, как это повлияет на производительность ( наверняка, он будет собран "сборщиком мусора"). Интересна эта ситуация с точки зрения поведения промисов. Промисы не могут быть отменены (иначе нарушится принцип иммутабельности промисов о котором мы поговорим позднее) — поэтому они могут быть проигнорированы.

Но что, если на использование `foo()` уже выделились определенные ресурсы, но таймаут сработал раньше и промис проигнорировался? Есть ли что-то в этом паттерне для проактивного освобождения выделенных ресурсов после таймаута? Или другими словами: как отменить сайд-эффекты, которые этот промис мог иметь? Что, если все, что нам нужно - это лишь залогировать факт того, что `foo()` не сработал вовремя?

Некоторые разработчики внесли предложение о `finally()`: колбэке, который всегда вызывается, когда промис зарезолвится, и, если нужно проведет чистку. На данный момент этого не существует в спецификации, но может появиться в ES7+. Поживем-увидим.

Это может выглядеть как-то так:

```javascript
var p = Promise.resolve( 42 );

p.then( something )
.finally( cleanup )
.then( another )
.finally( cleanup );
```

**Примечание:** В некоторых библиотеках промисов `finally()` возвращает новый промис (сохраняя цепочку). Если функция `cleanup()`  возвратит промис, то он свяжется с цепочкой. Это значит, что вы все еще можете иметь необработанные ошибки о которых мы говорили ранее.

Тем временем мы могли бы сделать статическую вспомогательную утилиту, которая позволяет нам наблюдать (без вмешательства) за работой промиса:

```javascript
// проверка срабатывания полифила
if (!Promise.observe) {
	Promise.observe = function(pr,cb) {
		//  наблюдаем за выполнением `pr`
		pr.then(
			function fulfilled(msg){
				// запланированный колбэк (или задача)
				Promise.resolve( msg ).then( cb );
			},
			function rejected(err){
				// запланированный колбэк (или задача)
				Promise.resolve( err ).then( cb );
			}
		);

		// возвращаем изначальный промис
		return pr;
	};
}
```

Вот как мы будем использовать утилиту в примере таймаута:

```javascript
Promise.race( [
	Promise.observe(
		foo(),
		function cleanup(msg){
			// производим "сборку мусора"
			// если foo() не выполнился вовремя
		}
	),
	timeoutPromise( 3000 )
] )
```

`Promise.observe(..)` - это просто иллюстрация того, как вы могли наблюдать работу промисов, не мешая им. Другие библиотеки промисов имеют собственные решения. Независимо от того, как вы это сделаете, у вас, вероятно, будут случаи, где вы хотите убедиться, что ваши промисы не просто игнорируются.

### Вариации all([ .. ]) и race([ .. ])

`Promise.all([ .. ])` и `Promise.race([ .. ])` встроены в стандарт ES6, это позволяет создавать другие паттерны, основанные на семантике этих методов:

* `none([..])` повторяет `all([..])` с одной разницей - fullfillment и rejection меняются местами. Т.е мы ждем пока *все* промисы зареджектятся.

* `any([..])` повторяет `all([..])`, но игнорирует реджекты, таким образом нужно чтобы успешно выполнился хотя бы один промис из всех.

* `first([..])` похож на гонку с `any([..])`. После того, как первый промис успешно выполнится, все остальные игнорируются.

* `last([..])` это `first([..])` наоборот. Важно успешное выполнение *последнего* промиса.

Некоторые библиотеки предоставляют эти методы, но вы можете написать свои, используя механику `all([])` и `race([])`.

Например, вот так можно реализовать `first([..])`:

```javascript
// проверка срабатывания полифила
if (!Promise.first) {
	Promise.first = function(prs) {
		return new Promise( function(resolve,reject){
			// проходимся циклом по всем промисам
			prs.forEach( function(pr){
				Promise.resolve( pr )
				// независимо от того, кто выиграет
				// основной промис зарезолвится
				.then( resolve );
			} );
		} );
	};
}
```

**Примечание:** `first([..])` не зареджектится, если все промисы в нем зареджектятся. В такой ситуации он просто зависнет, как и  `Promise.race([ .. ])`. Если хотите, то можете самостоятельно реализовать дополнительную логику, где будете отслеживать каждый реджект, и, если зареджектится всё, то вызывать `reject()` на основном промисе.

### Параллельные итерации

Иногда вам требуется провести какую-то итерацию над списком промисов и совершить какое-то действие над каждым из них, также, как это делается в синхронных методах (`forEach(..)`, `map(..)`, `some(..)`, и `every(..)`). Если действие, совершаемое над каждым промисом синхронное, то все будет работать нормально (`forEach` из примера выше).

Но если действия асинхронны или могут/должны выполняться одновременно, вы можете использовать асинхронные версии этих методов, это предусмотрено многими библиотеками.

Например асинхронная реализация метода `map(..)`, который принимает массив и применяет к каждому элементу функцию. `map(..)` возвращает промис, успешное значение которого (fullfillment) - это массив, который содержит результат каждого из промисов, к которому `map()` применил функцию:

```javascript
if (!Promise.map) {
	Promise.map = function(vals,cb) {
		// новый промис, который ждет обработку всех промисов
		return Promise.all(
			// map превращает массив значений, в массив промисов
			vals.map( function(val){
				return new Promise( function(resolve){
					cb( val, resolve );
				} );
			} )
		);
	};
}
```
**Примечание:** В этой реализации `map()`  нет уведомлений об асинхронных реджектах. Если происходит синхронная ошибка внутри колбэка `cb(..)`, то главный промис зареджектится.

Давайте проиллюстрируем использование `map()` с массивом промисов, а не простых значений:

```javascript
var p1 = Promise.resolve( 21 );
var p2 = Promise.resolve( 42 );
var p3 = Promise.reject( "Oops" );

Promise.map( [p1,p2,p3], function(pr,done){
	// Убедимся, что каждый элемент это промис
	Promise.resolve( pr )
	.then(
		// получим значение `v`
		function(v){
			// преобразуем fulfillment-значение `v` в новое значение
			done( v * 2 );
		},
		// или преобразуем в значение отклонения
		done
	);
} )
.then( function(vals){
	console.log( vals );	// [42,84,"Oops"]
} );
```

## Краткое содержание API промисов

Давайте посмотрим на ES6 реализация API промисов, части которого мы много раз использовали в этой главе:

**Примечание**: нативное API промисов поддерживается только внутри ES6, однако существуют специальные полифилы, позволяющие использовать промисы в пре-ES6 браузерах. Один из таких [полифилов](http://github.com/getify/native-promise-only) написан мною!

### new Promise(..) конструктор

*Раскрывающий конструктор* `Promise()` должен использоваться вместе с `new` и должен иметь колбэк, который вызывается синхронно/немедленно. Колбэк принимает два других колбэка, которые выступают в качестве возможных вариантов выполнения. Они называются `resolve()` и `reject()`:

```javascript
var p = new Promise( function(resolve,reject){
	// `resolve(..)` для успешного выполнения
	// `reject(..)` для отклонения
} );
```

`reject(..)` просто отклоняет промис. `resolve(..)` может или отклонить или успешно выполнить промис, в зависимости от того, какое значение в него попадет. Если `resolve(..)` принимает конкретное, не-промис, не-`thenable` значение, то он немедленно успешно выполнится с этим значением (fullfillment).

Если `resolve(..)` принимает промис или `thenable`, тогда в результате мы получим промис.

### Promise.resolve(..) и Promise.reject(..)

Шорткат для создания промиса в rejection-состоянии это `Promise.reject(..)`, эти две записи эквивалентны:

```javascript
var p1 = new Promise( function(resolve, reject){
	reject( "Oops" );
} );

var p2 = Promise.reject( "Oops" );
```

`Promise.resolve()` используется для создания промиса в состоянии fullfillment. Однако также `Promise.resolve()` распаковывает `thenable` значения (мы видели это ранее). В этом случае в результате мы получим промис, который уже можно или зареджектить или успешно выполнить (fullfill).

```javascript
var fulfilledTh = {
	then: function(cb) { cb( 42 ); }
};
var rejectedTh = {
	then: function(cb,errCb) {
		errCb( "Oops" );
	}
};

var p1 = Promise.resolve( fulfilledTh );
var p2 = Promise.resolve( rejectedTh );

// `p1` успешно выполнится
// `p2` зареджектится
```

И помните `Promise.resolve()` не сделает ничего, если переданный аргумент это настоящий промис. Метод просто вернет этот промис назад. Поэтому нет никого оверхэда в вызове `Promise.resolve()` со значениями о характере которых вы не знаете.

### then(..) и catch(..)

Каждый промис имеет `then()` и `catch()` методы, позволяющие использовать обработчики состояний (fullfillment и rejection). Как только промис зарезолвится, то вызовется один их этих обработчиков, но не оба сразу! Обработчики всегда будут вызываться асинхронно (см. "Задания" в Главе 1).

`then()` принимает один или два параметра, первый нужен для `fullfillment-стадии`, второй для `rejection-стадии`. Если параметр либо опускается, либо иным образом передается как не-функция, то он заменяется на дефолтный колбэк. fullfillment-колбэк просто передаст значение дальше, и rejection-колбэк по умолчанию просто передает причину ошибки, которую он получает.

`catch()` принимает только rejection-колбэк

```javascript
p.then( fulfilled );

p.then( fulfilled, rejected );

p.catch( rejected ); // или `p.then( null, rejected )`
```

`then()` и `catch()` также создают новый промис, который можно использовать для связывания. Если в обработчике состояния будет исключение, то вернувшийся промис зареджектится. Или, если колбэк вернет конкретное, не-промис, не-`thenable` значение, то оно установится, как fullfillment-значение для возвращаемого промиса. Если fullfillment-хендлер получит промис или `thenable`, то произойдет "распаковка" этого значения и это значение передастся в возвращаемый промис.

### Promise.all([ .. ]) и Promise.race([ .. ])

`Promise.all([ .. ])` - все промисы, которые вы передали в массив должны успешно выполниться (стать fullfillment), чтобы основной промис тоже успешно выполнился. Если хотя бы один из промисов в массиве зареджектится, то основной промис зареджектится тут же (сбрасывая результаты остальных промисов в массиве). Для успешного выполнения основного промиса вы должны получить массив значений всех промисов. Для отклонения достаточно одного отклоненного промиса. Этот паттерн называется "врата": все должны собраться перед вратами, чтобы они открылись.

`Promise.race([ .. ])` - первый успешно выполненный промис "выигрывает", и его значение попадает в возвращаемый промис. Этот паттерн называется "защелка": первый, кто пришел, тот открывает защелку.

Примеры:

```javascript
var p1 = Promise.resolve( 42 );
var p2 = Promise.resolve( "Hello World" );
var p3 = Promise.reject( "Oops" );

Promise.race( [p1,p2,p3] )
.then( function(msg){
	console.log( msg );		// 42
} );

Promise.all( [p1,p2,p3] )
.catch( function(err){
	console.error( err );	// "Oops"
} );

Promise.all( [p1,p2] )
.then( function(msgs){
	console.log( msgs );	// [42,"Hello World"]
} );
```

**Внимание:** Будьте осторожны! Если пустой массив передать в `Promise.all([ .. ])`, то он сразу станет fulfillment. Если пустой массив передать в `Promise.race([ .. ])`, то он зависнет навечно! Помните об этом!

API промисов в ES6 простое и понятное. По крайней мере его хватает, чтобы покрыть большинство тривиальных асинхронных задач, и начать превращать свой "callback hell" во что-то более лучшее.

Однако, в приложениях часто существуют определенные асинхронные тонкости, реализация которых затруднена из-за определенных ограничениях в промисах. Мы подробнее рассмотрим эти ограничения далее.

## Ограничения промисов

Многие подробности, которые мы обсудим, уже упоминались в этой главе, но теперь мы остановимся на них более подробно.

### Последовательная обработка ошибок

В этой главе мы подробно рассмотрели обработку ошибок с использованием промисов. Тут ограничение связано с дизайном промисов - а именно с механизмом связывания. Ошибка в цепочке промисов с легкостью может быть проигнорирована.

Но есть еще кое-что, что нужно учитывать при ошибках промисов. Поскольку цепочка промисов - это не что иное, как составляющие ее промисы, то нет никакой сущности, чтобы ссылаться на всю цепочку целиком, а это означает, что нет никакого внешнего способа наблюдать за любыми ошибками, которые могут произойти.

Если вы создадите цепочку промисов, в которой нет обработки ошибок, любая ошибка в любой точке цепочки будет беспрепятственно распространяться по цепочке до тех пор, пока не будет поймана (путем создания обработчика ошибок на каком-нибудь из шагов). Итак, в этом конкретном случае достаточно создать обработчик на *последнем* промисе в цепочке (`p`):

```javascript
// `foo(..)`, `STEP2(..)` and `STEP3(..)` это
// утилиты, использующие промисы

var p = foo( 42 )
.then( STEP2 )
.then( STEP3 );
```

Ни один шаг в цепочке не выполняет свою собственную обработку ошибок. Это означает, что вы могли бы повесить обработчик ошибок на `p`, и  уже он будет обрабатывать ошибки, возникающие в цепочке:

```javascript
p.catch( handleErrors );
```

Но, если каждый шаг в цепи будет иметь свой обработчик ошибок, то `handleErrors(..)` не будет уведомлен об ошибках (будет работать вхолостую). Полное отсутствие возможности быть уведомленным (об «уже обработанных» ошибках) является ограничением, которое подавляет возможности промисов в некоторых случаях использования.

Это является схожим с ограничением в `try...catch`, когда ошибка отлавливается, но никак не обрабатывается. Как видите это ограничение присуще *не только промисам*, и есть над чем подумать, чтобы обойти его.

К сожалению, во многих случаях в цепочках промисов не содержится ссылки, без таких ссылок вы не можете прикреплять обработчики ошибок, чтобы надежно наблюдать за ними.

### Одиночное значение

У промисов по определению может только одно успешное значение или только одно значение отклонения. В простых примерах это не играет большой роли, однако есть ряд сценариев, где такое поведение будет ограничивать разработку.

Типичным решением будет создание обертки (массива или объекта), которая будет хранить множественные значения. Решение рабочее, но может быть довольно неудобно извлекать значения из обертки на каждом шаге промисов.

#### Разделение значений

Эту проблему можно решить, разложив выполнение на два и более промиса.

Представьте, что у вас есть функция `foo()`, которая обрабатывает два значения (`x` и `y`) асинхронно:

```javascript
function getY(x) {
	return new Promise( function(resolve,reject){
		setTimeout( function(){
			resolve( (3 * x) - 1 );
		}, 100 );
	} );
}

function foo(bar,baz) {
	var x = bar * baz;

	return getY( x )
	.then( function(y){
		// обернем оба значения в контейнер
		return [x,y];
	} );
}

foo( 10, 20 )
.then( function(msgs){
	var x = msgs[0];
	var y = msgs[1];

	console.log( x, y );	// 200 599
} );
```

Во-первых, давайте поменяем то, что возвращает `foo()`. Вместо массива, содержащего `x` и `y` , обернем каждое из значений в промис.

```javascript
function foo(bar,baz) {
	var x = bar * baz;

	// возвращаем оба промиса
	return [
		Promise.resolve( x ),
		getY( x )
	];
}

Promise.all(
	foo( 10, 20 )
)
.then( function(msgs){
	var x = msgs[0];
	var y = msgs[1];

	console.log( x, y );
} );
```

Лучше ли массив промисов, чем один массив, передаваемый в промис? Синтаксически это будет большим улучшением.

Но этот подход гораздо ближе к теоретическим основам промисов. В дальнейшем будет проще рефакторить функции, вычисляющие значения `x` и `y`. Это более ясное и гибкое решение, позволяющее программе решать, как выполнять промисы -- через `Promise.all([ .. ])`, но это не единственное решение -- чем описывать каждую абстракцию внутри `foo()`.

#### Разворачивание аргументов

`var x = ..` и `var y = ..` присваивания все еще неудобные. Мы можем использовать один трюк (снимаю шляпу перед Reginald Braithwaite, @raganwald в Твиттере):

```javascript
function spread(fn) {
	return Function.apply.bind( fn, null );
}

Promise.all(
	foo( 10, 20 )
)
.then(
	spread( function(x,y){
		console.log( x, y );	// 200 599
	} )
)
```

Выглядит лучше! Конечно, вы можете заинлайнить этот трюк, чтобы не создавать дополнительную функцию:

```javascript
Promise.all(
	foo( 10, 20 )
)
.then( Function.apply.bind(
	function(x,y){
		console.log( x, y );	// 200 599
	},
	null
) );
```

Такие трюки могут быть полезными, но ES6 имеет еще более лучшее решение: деструктурирование. Деструктивное присваивание массива выглядит примерно так:

```javascript
Promise.all(
	foo( 10, 20 )
)
.then( function(msgs){
	var [x, y] = msgs;

	console.log( x, y );	// 200 599
} );
```

Но, что лучше всего, ES6 позволяет задать массив параметром функции:

```javascript
Promise.all(
	foo( 10, 20 )
)
.then( function([x, y]){
	console.log( x, y );	// 200 599
} );
```

Мы реализовали решение "одно значение - один промис", и при этом сократили наш код до минимума.

**Примечание:** подробнее о формах деструктурирования вы прочтете в моей книге, посвященной ES6.

### Одиночное выполнение

Одной существенной чертой промисов, является то, что промис может зарезолвиться только один раз (fullfillment или rejection). Для многих случаев, где вы получаете значение один раз, это работает нормально.

Но есть также много асинхронных случаев, которые вписываются в другую модель:  один случай похож на события и/или поток данных. Не совсем понятно, насколько хорошо промисы будут подходить в этом случае, если вообще подойдут. Без дополнительной абстракции, промисы не справятся.

Представьте себе сценарий, в котором вам может потребоваться прервать последовательность асинхронных шагов в ответ на событие, которое может произойти несколько раз, например, нажатие кнопки:

```javascript
// `click(..)` связывает "click" событие с DOM элементом
// `request(..)` утилита, использующая промисы

var p = new Promise( function(resolve, reject){
	click( "#mybtn", resolve );
} );

p.then( function(evt){
	var btnID = evt.currentTarget.id;
	return request( "http://some.url.1/?id=" + btnID );
} )
.then( function(text){
	console.log( text );
} );
```

Это решение сработает только в том случае, если на кнопку нажмут один раз. Если на кнопку нажмут во второй раз, к этому моменту `p` зарезолвится, и второй вызов `resolve()` будет проигнорирован.

Другим приемом может стать создание новой цепочки промисов для каждого срабатывания события:

```javascript
click( "#mybtn", function(evt){
	var btnID = evt.currentTarget.id;

	request( "http://some.url.1/?id=" + btnID )
	.then( function(text){
		console.log( text );
	} );
} );
```

Но помимо просто неудобства в том, что нужно определить целую цепочку промисов внутри обработчика событий, эта конструкция в некоторых отношениях нарушает идею разделения "проблем/возможностей" (SoC). Возможно, вам очень хотелось бы определить обработчик событий в другом месте вашего кода, откуда вы управляете реакцией на событие. Без вспомогательных механизмов тут это сложно реализовать.

**Примечание:** другой способ обойти это ограничение, заключается в использовании абстракции "observable", с помощью которой можно следить за цепочкой промисов. Есть библиотеки, предоставляющие такую абстракцию ( например [RxJS](http://reactivex.io/rxjs/)), но эти абстракции могут показать такими большими, что из за них не видно самих промисов. Более того использования таких абстракций, вызывает ряд вопросов, связанных с "проблемами доверия". Так или иначе, посмотрите на реализацию "observable" в приложении A.

### Инертность

Еще одно ограничение связано с тем, что в приложении может существовать код, не готовый к использованию промисов. Если у вас много кода использующего колбэки, то лучше продолжать разработку в этом стиле ( на колбэках, без промисов).

"Код на колбэках будет кодом на колбэках, до тех пор пока не попадет к разработчику, знающему о промисах". Народная мудрость.

Промисы предполагают другую парадигму: где то она лишь немного будет отличаться, а где-то совершенно радикально.

Рассмотрим вот такой пример на колбэках:

```javascript
function foo(x,y,cb) {
	ajax(
		"http://some.url.1/?x=" + x + "&y=" + y,
		cb
	);
}

foo( 11, 31, function(err,text) {
	if (err) {
		console.error( err );
	}
	else {
		console.log( text );
	}
} );
```

Можно ли сходу понять, как переписать этот пример на промисы? Зависит от вашего опыта. Конечно, на промисах нет этикетки со способом применения, поэтому вся реализация лежит на вас.

Как мы уже говорили ранее, нам нужна ajax-утилита, которая использует промисы вместо колбэков. Вы можете написать ее сами, как мы уже делали. Но неудобства, связанные с необходимостью вручную определять оболочки промисов для каждой утилиты, работающей на колбэках, отобьет всякое желание использовать промисы вообще.

Промисы не дают прямого указания на обход такого ограничения. Однако большинство библиотек предоставляют некоторые решения. Без библиотек же решение будет выглядеть как то так:

```javascript

// проверка работы полифила
if (!Promise.wrap) {
	Promise.wrap = function(fn) {
		return function() {
			var args = [].slice.call( arguments );

			return new Promise( function(resolve, reject){
				fn.apply(
					null,
					args.concat( function(err, v){
						if (err) {
							reject( err );
						}
						else {
							resolve( v );
						}
					} )
				);
			} );
		};
	};
}
```

Да, конечно, это больше, чем просто крошечная утилита. Однако, пугающая с первого взгляда, она не так сложна, как вы думаете. Она принимает функцию, которая принимает "error-first" колбэк и возвращает новый, который автоматически создает промис, подключенный к rejection/fullfillment.

Вместо того, чтобы тратить время на разговоры о том, *как* `Promise.wrap` работает, давайте посмотрим, как его можно использовать:

```javascript
var request = Promise.wrap( ajax );

request( "http://some.url.1/" )
.then( .. )
..
```

Ого! Так просто!

`Promise.wrap()` не создает промис. Он создает функцию, которая создаст промис. В некотором смысле можно считать эту функцию "фабрикой промисов". Я предложил свое название - "промисор" [от англ. Promisory ("promise" + "factory")]

Оборачивание функции в промис также иногда называют "промисификацией". Я предпочитаю "промисор", так как это название более точно описывает суть.

Итак `Promise.wrap(ajax)` создает промисор, который мы назвали `request()` , этот промисор создает промис для обработки ajax-ответов.

Вернемся к примеру, который мы рассматривали ранее, нам нужны промисоры для `ajax()` и для `foo()`:

```javascript
// создаем промисор для `ajax(..)`
var request = Promise.wrap( ajax );

// отрефакторим `foo(..)`, но сохраним
// возможность использования колбэков
// для совместимости с другими частями программы
function foo(x,y,cb) {
	request(
		"http://some.url.1/?x=" + x + "&y=" + y
	)
	.then(
		function fulfilled(text){
			cb( null, text );
		},
		cb
	);
}

// создадим промисор для `foo(..)` ...
var betterFoo = Promise.wrap( foo );

// ...и используем его
betterFoo( 11, 31 )
.then(
	function fulfilled(text){
		console.log( text );
	},
	function rejected(err){
		console.error( err );
	}
);
```
Конечно, пока мы рефакторим `foo()`, чтобы использовать промисор `request()`, мы могли бы превратить `foo()` в промисор и не использовать `betterFoo()`. Делать так или нет, зависит от того, должен ли `foo()` оставаться колбэк-совместимым с другими частями программы или нет.

Рассмотрим:
```javascript
function foo(x,y) {
	return request(
		"http://some.url.1/?x=" + x + "&y=" + y
	);
}

foo( 11, 31 )
.then( .. )
..
```

Пока в ES6 нет нативной поддержки промисоров. Их предоставляют большинство библиотек или вы можете написать их самостоятельно. В любом случае конкретно это ограничение промисов, не несет много проблем (по сравнению с "callback hell", разумеется).

### Промис не отменить

Как только вы создадите промис и опишите для него обработчики выполнения, то уже ничто извне не сможет прервать его работу.

**Примечание:** Многие из библиотек промисов предоставляют утилиты для прерывания, но это ужасно! Многие разработчики хотят, чтобы была нативная возможность отменить промис. Но тогда появится проблема, когда один "потребитель" промиса, может повлиять на другого "потребителя" этого же промиса. Это нарушит принцип внешней иммутабельности, и более того - это реализация анти-паттерна ["дальнодействие"](https://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29). Независимо от того, насколько полезно это выглядит, это фактически приведет вас обратно в "callback hell".

Рассмотрим реализацию таймаута промиса из раннего примера:

```javascript
var p = foo( 42 );

Promise.race( [
	p,
	timeoutPromise( 3000 )
] )
.then(
	doSomething,
	handleError
);

p.then( function(){
	// все еще работает, даже в случае таймаута :(
} );
```

"Таймаут" это сущность извне, по отношению к `p`. `p` продолжает работать, что, вероятно, нежелательно.

Один из вариантов решения - это инвазивное определение колбэков:

```javascript
var OK = true;

var p = foo( 42 );

Promise.race( [
	p,
	timeoutPromise( 3000 )
	.catch( function(err){
		OK = false;
		throw err;
	} )
] )
.then(
	doSomething,
	handleError
);

p.then( function(){
	if (OK) {
		// случится только до таймаута :)
	}
} );
```

Выглядит ужасно! Решение рабочее, но далекое от идеала. Старайтесь избегать таких сценариев.

Но если избежать не получится, то нужно понимать, что отмена промиса - это функциональность, которая принадлежит более высокому уровню абстракции над промисами. Я бы порекомендовал вам искать библиотеки таких абстракций для помощи, а не пытаться реализовать такой прием самому.

**Примечание:** В приложении А можно посмотреть на мою библиотеку, предоставляющую такую абстракцию и метод `abort()` для прерывания последовательности.

Одиночный промис не может быть инструментом управления потоком, в отличие от цепочки промисов. Поэтому отмена промисов должна быть определена именно на этом уровне абстракции.

### Производительность промисов

Это ограничение одновременно простое и сложное.

Если сравнивать асинхронную задачу на колбэках и цепочку промисов, то промисы несколько медленнее. Однако подумайте о тех гарантиях, которые дают промисы "из коробки", по сравнению с тем количеством вспомогательного кода, которое придется "городить" руками для колбэков.

Но насколько медленнее промисы? Ну... на самом деле это очень сложный вопрос, чтобы ответить конкретно.

Откровенно говоря, это что-то типа сравнения апельсинов с яблоками. Возможно такой вопрос некорректный.

Тем не менее, если мы согласны с тем, что промис, как правило, немного медленнее, чем его небезопасный эквивалент колбэк - если у вас есть места, в которых вы чувствуете, что можно закрыть глаза на "проблемы доверия" - означает ли это, что нужно отказаться от промисов, как будто всё, что нужно вашему приложению это только быстро работающий код?

Если ваше приложение именно такое, то задайте себе вопрос: а правильно ли было использовать JavaScript для таких задач? JavaScript можно "прокачать" до очень высокого уровня производительности (см. главу 5 и 6). Уместно ли искать альтернативы промисам в свете всех преимуществ, который они дают?

Ещё одна тонкая проблема в том, что промисы делают асинхронным все к чему прикоснутся. Это значит, что синхронные действия будут откладывать переход к следующему шагу (см. Главу 1). Это также означает, что цепочка промисов будет выполнятся медленнее, чем аналогичная цепочка на колбэках.

Вместо того, чтобы повышать производительность путем избегания всех преимуществ промисов, лучше воспользоваться профилированием и проанализировать критические точки вашего приложения. Тогда станет ясно: действительно ли промисы в вашем приложении это "бутылочное горлышко" или нет?

Промисы немного медленнее, но взамен вы получаете встроенную надежность и предсказуемость. Может быть, ограничение промисов связано с вашим непониманием их преимуществ?

## Итоги

Промисы прекрасны! Используйте их. Они решают проблемы "инверсии контроля", которые отравляли нам разработку, когда мы использовали колбэки.

Они не избавляются от колбэков, они просто перенаправляют управление ими на надёжный механизм, который находится между нами и другой утилитой.

Цепочка промисов также относится к способу управления асинхронным потоком в виде последовательности, что помогает нашему мозгу лучше планировать и поддерживать асинхронный JS-код. Мы увидим еще более лучшее решение этой проблемы в следующей главе!
